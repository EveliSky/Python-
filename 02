'''
列表和元组
Python中最基本数据结构是序列，每一个序列都分配一个序号
，称索引，从0开始。
2.1 序列概览
6中内建序列：列表，元组，字符串，Unicode字符串，buffer对象，xrange对象
列表几乎所有情况下都可以代替元组。元组的一个特点是一旦初始化就不能修改。
列表 edward = ['Edward Gumby',42]
列表元素也可以是列表
容器的数据结构，基本上可以包含任意对象。序列(列表和元组)和映射(字典)是两类主要容器，
2.2 通用序列操作
索引indexing，分片sliceing，加adding，乘multiplying，成员资格，是否属于序列
序列长度，最大，最小元素的内建函数
迭代
2.2.1 索引
greeting = 'Hello'
greeting[0] H
使用负数会从结尾开始，最后一个元素是-1
greeting[-1] o
raw_input()[3] 会返回输入的第四个字符
2.2.2 分片
分片可以访问一点范围内的元素
numbers = [1,2,3,4,5,6,7,8,9,10]
numbers[3:6]  [4,5,6] 从第四个元素开始，到第5个元素结束
                      从第一个索引开始；最后一个索引是保留的第一个元素 [   ) 左闭右开
numbers[7:10] [8,9,10] 索引10没有这个元素，但是要作为边界提供
numbers[-3,0] []  左边索引位置比右边索引位置在序列中更靠右，就是空列表。-3位置比0位置更靠右。
numbers[-3:]  [8,9,10] 从-3位置开始，直到结束
numbers[:3]  [1,2,3]  从第一个元素开始，直到第三个元素结束
numbers[:] 等价于复制整个数组，产生新的数组。如果x = y 这意味着x和y指向同一个对象。
numbers[0:10:1] 从0开始到10结束，步长为1
numbers[0:10:2] [1,3,5,7,9] 从0开始到10结束，步长为
numbers[::4] [1,5,9]  每四个元素取出第一个元素
numbers[8:3:-1] [9,8,7,6,5] 负数步长从右向左提取元素，注意分片索引写法，左边索引位置要比右边索引位置更靠右。
2.2.3 序列相加
[1,2,3] + [4.5.6] [1.2.3.4.5.6] 相同类型的序列可以直接相加，组成新的连续序列
2.2.4 乘法
'python'*5 'pythonpythonpythonpythonpython' 原序列会被重复5次
[] 空列表 [] * 5 仍然是 []
[None]*5 [None,None,None,None,None] 占位为5的空列表
2.2.5 成员资格
permissions = 'rw'
'w' in permissions True 返回布尔值
'x' in permissions False
2.2.6 长度，最小值和最大值
numbers = [100,34,678]
len(numbers) 3 长度
max(numbers) 678 最大值
min(numbers) 34 最小值
max(2,3) 3 接受多个参数
min(2,3) 2
2.3 列表 Python的苦力
列表是可变的mutable
2.3.1 list函数
字符串不能像列表一样直接进行修改。一般是根据字符串创建列表
list('Hello') ['H','e','l','l','o']
''.join(list对象) 会将list转换为字符串
2.3.2 列表基本操作
x = [1,1,1] x[1] =2 x    [1,2,1] 直接赋值，改变列表
names = ['Alice','Beth','Cecil','Dee-Dee','Earl']
del names[2]
['Alice','Beth','Dee-Dee','Earl'] 删除元素
name = ['P','e','r','l']
name[1:] = list('ython')  ['P','y','t','h','o','n'] 批量赋值；而且可以自动延长
numbers = [1,5]
numbers[1:1] = [2,3,4] [1.2.3.4.5]  替换了一个空元素 ，结果等同于插入新元素
numbers  [1.2.3.4.5]  现在是五个元素
numbers[1:4] = []  [1,5]  中间几个元素被替换为空元素，结果等同于删除元素
2.3.3 列表方法
列表对象提供了一系列方法可供使用
有些方法直接修改原列表(原位置操作)，有些方法只会返回一个结果，如何利用结果是用户的事情。
lst=[1,2,3] lst.append(4)  [1,2,3,4] append在原列表结尾追加新的对象

lst.count(1) 1 统计元素出现的次数，count参数可以是列表

a = [1,2,3] b = [4,5,6] a.extend(b) [1,2,3,4,5,6] extend修改了原始列表，而相加操作会产生一个结果，不改变原列表。

knights = ['We'.'are','the','knights','who','say','nil']
knights.index('who') 4 返回who所在的位置编号。如果元素不存在会报错。

numbers = [1,2,3,4,5,6,7]
numbers.insert(3,'four') [1,2,3,'four',5,6,7] 在指定位置上插入新元素

numbers = [1,2,3] numbers.pop() 3
numbers [1,2] pop做为栈结构会弹出最后一个进入的数据，原位置操作，而且会返回弹出值

x = [1,2,4,'who','6','ooo','who']
x.remove('who')  [1,2,4,'6','ooo','who'] 移除第一个匹配项。不在列表内的元素会报错。

x = [1.2.3]
x.reverse()  [3,2,1] 反向存放，原位置操作

x = [4,6,2,1,7,9]
x.sort()   [1,2,4,6,7,9] 元素排序，原位置操作
sorted(x) 会返回一个排序好的列表对象

cmp(a,b)  内建比较函数，a>b 1 a<b -1 a=b 0
numbers = [5,2,9,7]
numbers.sort(cmp) [2,5,7,9]  如果传入其他cmp函数，可以按照自己的要求改变【排序规则
x = ['adrdvark','abalone','acme','add','aerate']
x.sort(key=len) 按照字符串长度进行排序
x= [4,6,2,1,7,9]
x.sort(reverse=True) 直接进行反向排序
x [9,7,6,5,4,2,1]

2.4 元组 不可变序列
元组一旦穿件就不可修改，如同字符串一样
自动创建了一个元组
1,2,3  (1,2,3) 隐式创建
(1,2,3) (1,2,3) 显式创建
() 空元组
42, (42,) 单元素元组，需要加一个逗号
(42,) (42,)
3*(40+2)  126
3*(40+2,) (42,42,42) 元组重复三次
2.4.1 tuple函数
tuple([1,2,3]) (1,2,3) 穿入一个参数，转换为元组
2.4.2 元组基本操作
可以创建和访问(下标，分片)，没有其他的操作。
2.4.3 元组意义
元组可以在映射和集合的成员中当做键，列表不可以
元组作为很多内建函数和普通函数的返回值存在，必须要处理。
'''
