测试
自动化测试流程，除了标准库中的测试和分析工具外，还可以用PyChecker和PyLint
16.1 先测试后编码
做单元测试在极限编程中被证明极为有用。这种测试过程也称为测试驱动编程。
16.1.1 精确的需求说明
需求说明明确程序的目标。
先编写测试程序，再编写可以通过测试的程序。测试程序就是需求说明。
x = 12
y = 4
correct_z = 16
z = youradd(x,y)
if z == correct:
    True
else:
    False
有测试，可以证明某特性存在。之后可以明确证明函数实现了特性。
16.1.2 为改变而计划
自动化测试还可以避免在实施修改时增加错误。
编写程序应当做好修改代码的准备，而不是固守已有的程序。
但是改变可能会带来其他的不可预料的错误。
如果程序设计足够好，改变产生的影响就是局部的，只会影响一小部分，定位错误更方便。
覆盖度。测试时，可能没有运行代码的全部，一般不会使用所有可能的输入。优秀的测试
程序组要有良好的覆盖度。覆盖度工具，可以衡量在测试过程中实际运行的代码百分比。
如果手头没有一个周详的测试机，就有可能意识不到有错误进入了程序。如果没有一套好
的测试程序，很难找到错误。测试驱动编程的原则就是确保拥有好的测试覆盖度。
16.1.3 测试的4步
1指出新特性，为其编写测试。
2编写特性需要的概要代码。这样语法没有错误，但测试会失败。验证测试可以失败是很重要的。
如果测试不失败，那测试没有意义。
3位特性的概要编写虚设代码，能满足测试要求就行。只要保证测试通过就行。验证测试可以成功。
4重写代码，让代码做应该做的事情，并且保证测试能够一直成功。
完成编码时，应该保证代码处于健康的状态，不要遗留任何测试失效。
16.2 测试工具
16.2.1 doctest
def square(x):
    """


    >>>square(2)
    4
    >>>square(3)
    9
    """
    return x*x
#函数定义在my_math模块
if __name__=='__main__'
    import doctest,my_math
    doctest.testmod(my_math)

doctest.testmod函数从一个模块读取所有文档字符串，找出所有看着像交互式解释器中输入的例子的文本，
之后检查例子是否符合实际要求
16.2.2 unittest
能以更结构化的方式编写大型且周详的测试组。
unittest.main()会自动运行所有TestCase的子类，运行所有名字以test开头的方法
16.3 单元测试以外的内容
其他的方法来探索程序，源代码检查和分析。源代码检查是一种寻找代码中普通错误或者问题的方法。分析
则是查明程序到底能跑多快的方法。
16.3.1 使用PyChecker和PyLint检查源代码
安装好工具后
pychecker file1.py file2.py
pylint module
自动化检查工具有其限制，并不是万能的
16.3.2 分析
import profile
profile.run('product(1,2')
会打印各个函数和方法调用的次数，以及每个函数所花费的时间。

